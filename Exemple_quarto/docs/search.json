[
  {
    "objectID": "R/Nuage_de_mot/nuage_de_mot.html",
    "href": "R/Nuage_de_mot/nuage_de_mot.html",
    "title": "Exemple_quarto",
    "section": "",
    "text": "Comme dans tout bon code R il est nécessaire au début d’installer (une fois sur un ordinateur): (dans le terminal de commande ) install.packages(“tm”) # pour le text mining install.packages(“SnowballC”) # pour le text stemming install.packages(“wordcloud”) # générateur de word-cloud install.packages(“RColorBrewer”) # Palettes de couleurs les packages recquis pour le code et de charger (à chaque fois ) les librairies requisent pour le code.\n\n# ---- library ----\nlibrary(\"tm\") # pour le text mining\n\nLoading required package: NLP\n\nlibrary(\"SnowballC\") # pour le text stemming\nlibrary(\"wordcloud\") # générateur de word-cloud \n\nLoading required package: RColorBrewer\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\nLe text-mining (ou fouille de texte) est une technique d’analyse de données qui consiste à extraire des informations significatives à partir de données textuelles non structurées telles que des documents, des e-mails, des pages web, des tweets, etc.\nLe stemming est une technique de traitement automatique du langage naturel (TALN) qui consiste à réduire les mots à leur forme racine ou à leur base lexicale, en éliminant les suffixes ou les terminaisons des mots. Par exemple, le stemming pourrait transformer les mots “manger”, “mangeais” et “mangé” en leur forme racine “mang”.\nJ’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# Lire le fichier texte\nfilePath &lt;- \"C:/Users/cottet_cor/Documents/Stage/Exemple_quarto/R/Nuage_de_mot/genre.txt\"\ntext &lt;- readLines(filePath)\n\nWarning in readLines(filePath): incomplete final line found on\n'C:/Users/cottet_cor/Documents/Stage/Exemple_quarto/R/Nuage_de_mot/genre.txt'\n\n# Charger les données comme un corpus\ndocs &lt;- Corpus(VectorSource(text))\n\nPar la suite, il faut transformer un peu le texte pour ne gardez que l’essentiel, le coeur du sujet. Il faut donc supprimer les “stopword” (le,la,une,des,…).\n\n# ---- Transofrmation du texte ----\n\ntoSpace &lt;- content_transformer(function (x , pattern ) gsub(pattern, \" \", x)) \n\n# Convertir le texte en minuscule\ndocs &lt;- tm_map(docs, content_transformer(tolower)) \n\nWarning in tm_map.SimpleCorpus(docs, content_transformer(tolower)):\ntransformation drops documents\n\n# Supprimer les mots vides anglais\ndocs &lt;- tm_map(docs, removeWords, stopwords(\"fr\"))\n\nWarning in tm_map.SimpleCorpus(docs, removeWords, stopwords(\"fr\")):\ntransformation drops documents\n\n# Supprimer votre propre liste de mots non désirés\ndocs &lt;- tm_map(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")) \n\nWarning in tm_map.SimpleCorpus(docs, removeWords, c(\"blabla1\", \"'\", \"chez\")):\ntransformation drops documents\n\n# Supprimer les ponctuations\ndocs &lt;- tm_map(docs, removePunctuation)\n\nWarning in tm_map.SimpleCorpus(docs, removePunctuation): transformation drops\ndocuments\n\n# Supprimer les espaces vides supplémentaires\ndocs &lt;- tm_map(docs, stripWhitespace)\n\nWarning in tm_map.SimpleCorpus(docs, stripWhitespace): transformation drops\ndocuments\n\ninspect(docs) #inspecter le document\n\nS’il on veut supprimer des nombres, on utilise la syntaxe : “docs &lt;- tm_map(docs, removeNumbers)”\nOn réalise ensuite une table de fréquence d’apparition des mots\n::: {.cell}\n# table de fréquence de mot (voir table d'occurence)\ndtm &lt;- TermDocumentMatrix(docs)\nm &lt;- as.matrix(dtm)\nv &lt;- sort(rowSums(m),decreasing=TRUE)\nd &lt;- data.frame(word = names(v),freq=v)\nhead(d, 12) # affiche les 12 mots avec les plus grosses fréquences. \n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=brewer.pal(8, \"Paired\")) #réalisation du nuage de mots.\n::: {.cell-output-display}  :::\n# On pourrait faire quelque chose de beaucoup plus neutre en terme de couleur avec la commande :\n\n\nset.seed(1234)\n\nwordcloud(words = d$word, freq = d$freq, min.freq = 4,\n         max.words=200, random.order=FALSE, rot.per=0.35, \n         colors=\"black\")\n::: {.cell-output-display}  ::: :::\nC’est quoi le set.seed(1234) ? Lorsque vous utilisez une graine aléatoire (le set.seed(1234)), cela garantit que les résultats de votre analyse seront les mêmes à chaque fois que vous exécutez le code. Cela est particulièrement important lorsque vous travaillez avec des fonctions qui impliquent une certaine forme d’aléatoire, comme la génération de nuages de mots.\nAinsi, si vous utilisez la même graine aléatoire (par exemple, 1234) dans votre code chaque fois que vous exécutez l’analyse, vous obtiendrez toujours les mêmes résultats, ce qui facilite la reproductibilité de votre analyse. Sans fixer la graine aléatoire, la génération du nuage de mots peut varier à chaque exécution, car les fonctions qui génèrent le nuage de mots utilisent généralement des algorithmes aléatoires pour placer les mots dans l’espace et choisir les couleurs. Cela signifie que chaque fois que vous exécutez le code, vous obtiendrez un nuage de mots différent, même si les données d’entrée sont les mêmes.\nPour en apprendre plus sur la constrcution des images de mots : http://www.sthda.com/french/wiki/text-mining-et-nuage-de-mots-avec-le-logiciel-r-5-etapes-simples-a-savoir"
  },
  {
    "objectID": "R/Nuage_de_mot/nuage_de_mot_rtemis.html",
    "href": "R/Nuage_de_mot/nuage_de_mot_rtemis.html",
    "title": "Exemple_quarto",
    "section": "",
    "text": "# ----- Librairies ----\nlibrary(\"R.temis\")\n\nLoading required package: tm\n\n\nLoading required package: NLP\n\n\nLoading required package: slam\n\n\nLoading required package: FactoMineR\n\n\nLoading required package: explor\n\nlibrary(\"RColorBrewer\") # pour charger des couleurs dans le nuage de mot\n\n(N’oubliez pas d’installer les packages avant d’exéctuer les libraries si ceux-ci sont nouveaux!) Concernant le choix des données, j’ai choisis une publication de Mathieu Trachman datant de 2022 intitulé “Très masculin, pas très féminine. Les variations sociales du genre”, Population et Sociétés: 1-4, pour illustrer mon exemple.\n\n# ---- Import des données ----\ncorpus &lt;- import_corpus(\"C:/Users/cottet_cor/Documents/Stage/Exemple_quarto/R/Nuage_de_mot/genre.csv\",format=\"csv\",textcolumn=1,language=\"fr\")\n\nC’est quoi les stop_words?\nLes stop words (ou mots vides) sont des mots très courants dans un langage donné, comme les prépositions, les articles, les pronoms, etc., qui sont souvent omis lors de l’analyse de texte car ils ne portent pas de sens important pour la compréhension globale du texte.\n\n# ---- traitement des données ----\ndtmsmo &lt;-build_dtm(corpus, remove_stopwords = T, min_length = 0)\n\ndic &lt;-dictionary(dtmsmo) #création d'un dictionnaire de mot \n\nfrequent_terms(dtmsmo) #fréquence d'apparition des mots dans le texte en question\n\nIl est possible de faire un traitement plus poussé des données\n\n# ---- Générateur du Nuage ---- \ncloud&lt;-word_cloud(dtmsmo, color=brewer.pal(10, \"OrRd\"), min.freq=0) \n\nWarning in brewer.pal(10, \"OrRd\"): n too large, allowed maximum for palette OrRd is 9\nReturning the palette you asked for with that many colors\n\n\n\n\nterms_graph(dtmsmo, min_occ=1,interactive=T) #pour obtenir un graph de mots.\n\n[1] 1"
  },
  {
    "objectID": "R/Package_dplyr/quarto_dplyr.html",
    "href": "R/Package_dplyr/quarto_dplyr.html",
    "title": "Exemple_quarto",
    "section": "",
    "text": "Nous utiliserons dplyr comme package. dplyr est une grammaire de manipulation de données, fournissant un ensemble cohérent de verbes qui vous aide à résoudre les problèmes de manipulation de données les plus courants. https://www.rdocumentation.org/packages/dplyr/versions/0.7.8\n\n# ---- Librairie nécessaire pour le code ----\nlibrary(dplyr) \nlibrary(tidyverse) #pour utiliser \"%&gt;%\" (ou pipe) définit en dessous\n\nUne fois la librairie importée, nous devons importer les donnés pour pouvoir travailler dessus. Nous utilisons ici un exemple de fichier de traitement de données portant sur le titanic. Nous utiliserons le package Rio pour les importer.\n\ndata(starwars)\nView(starwars)\n\nMais comment puis-je filtrer ma table pour n’obtenir que les passagers situé dans la classe 2 à bord du titanic ?\nLe “pipe” ou opérateur “%&gt;%” en R permet d’enchaîner les opérations sur une table sans avoir à répéter le nom de la table à chaque étape. Cela simplifie la syntaxe et rend le code plus lisible en permettant d’écrire des enchaînements d’opérations sur une table de manière plus concise et efficace.\n\nstarwars&lt;-starwars %&gt;% filter(species==\"Human\")\n# sans l'opérateur %&gt;% on aurait : \nstarwars_filtered &lt;- filter(starwars, species == \"Human\")\n# une autre façon de filter sans utiliser le package dplyr est \nstarwars_filtered &lt;- starwars[starwars$species == \"Human\", ]\n\nComment est-ce que je peut ajouter des données à mon dataframe?\n\n#avec dplyr on utilise la fonction mutate() pour ajouter des colonnes\n# a notre dataframe. Pour afficher la nouvelle colonne dans le dataframe \n#on rajoute la commande select(nouvelle_colonne,everything())\nstarwars %&gt;% mutate(moyenne=mean(is.na(mass))) %&gt;% select(moyenne,everything())\n\nComment est-ce que je peux selectionner uniquement les colonnes qui m’interesse pour mon travail?\n\nstarwars %&gt;% select(species,gender) #on selectionne ici l'espèce et le genre\n\nComment est-ce que je peux grouper mes données ?\n\nstarwars %&gt;% group_by(species) # regroupe par espèce\n\n#La fonction tapply() est une autre fonction de base de R \n#qui permet de regrouper les données selon une ou plusieurs variables\navg_height_by_species &lt;- tapply(starwars$height, starwars$species, mean, na.rm = TRUE)\n\n#La fonction aggregate() est une fonction de base de R qui permet de regrouper les données selon une ou plusieurs variables \navg_height_by_species &lt;- aggregate(starwars$height, by = list(starwars$species), FUN = mean, na.rm = TRUE)\n\nPour en apprendre plus sur dplyr :\nhttps://cran.r-project.org/web/packages/dplyr/vignettes/dplyr.html"
  },
  {
    "objectID": "R/Package_purrr/package_purrr.html",
    "href": "R/Package_purrr/package_purrr.html",
    "title": "Exemple_quarto",
    "section": "",
    "text": "purrr est un package dédié à la programmation fonctionnelle. Ses fonctions principales sont les fonctions map() (map(), map_chr(), map_dbl(), map_dfr(), etc…), elles permettent d’appliquer une même fonction (ou une même série de fonctions) à chaque élément d’un ensemble (les colonnes d’un data frame, ou les éléments d’une list par exemple). En gros, ces fonctions map() permettent de remplacer les boucles for() avantageusement en termes de nombre de lignes de code et de temps de calcul (parce que ces fonctions reposent sur la récursivité).\n\nlibrary(purrr) \n\nA titre d’exemple on va essayer de supposer que nous avons une liste de vecteurs numériques et que nous allons appliquer une fonction à chaque vecteur pour en extraire la valeur maximale. Sans le package purr il est nécessaire d’utiliser une boucle for:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Initialiser un vecteur vide pour stocker les résultats\nmax_vals &lt;- numeric(length(my_list))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nfor (i in seq_along(my_list)) {\n  max_vals[i] &lt;- max(my_list[[i]])\n}\n# Afficher les résultats\nmax_vals\n\n[1] 3 6 9\n\n\nAvec le package purrr:\n\n# Créer une liste de vecteurs\nmy_list &lt;- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))\n\n# Appliquer la fonction max() à chaque vecteur de la liste\nmax_vals &lt;- map(my_list, max)\n\n# Afficher les résultats\nmax_vals\n\non remarque qu’on gagne quand même pas mal de temps d’écriture en utilisant le package purrr, ce qui peut vraiment servir quand on a de pas mal de ligne de code.\n\n\nPour en apprendre plus sur le package purr :\nhttps://delladata.fr/liste-de-ressources-pour-le-package-purrr/"
  },
  {
    "objectID": "R/Package_rio/Rio_package.html",
    "href": "R/Package_rio/Rio_package.html",
    "title": "Exemple_quarto",
    "section": "",
    "text": "L’import de données est la base de tout programme informatique portant sur le traitement de données. Le package “rio” est une collection de fonctions pour importer et exporter des données dans différents formats avec R. Il permet d’importer facilement des fichiers de données à partir de diverses sources, notamment des fichiers plats, des bases de données, des fichiers SAS, SPSS et Stata, ainsi que des fichiers Excel et RData. Il faut au préalable installer le package avec la commande suivante: ” install.packages(“rio”)“.\n\n# ---- Librairie ---- \n\nlibrary(rio)\ninstall_formats()\n\n[1] TRUE\n\n# --- import de données --- \n\n#Pour des données au format xlsx\n\ndata_xslx&lt;-import(\"election_leg.xlsx\") \n\n\n#Pour des données au format SAS (ou autre), c'est la même chose.\ndata_sas&lt;-import(\"chemin_d_acces.sas7bdat\")\n\nPour exporter une base de données dans un fichier, il est recommandé d’utiliser la méthode “export” en utilisant le dataframe que vous voulez exporter, ici “data_sas” (comme illustré ci-dessous), et en spécifiant le chemin où vous souhaitez le sauvegarder. Cette méthode est généralement utilisée lorsque vous apportez des modifications directes à votre dataframe et que vous souhaitez enregistrer les changements quelque part.\n\n# --- export de données ---\n\nchemin_acces&lt;-export(data_sas,\"election_leg.xlsx\")\n\nPour en apprendre plus sur le package rio https://rdocumentation.org/packages/rio/versions/0.5.29\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "R/R_vscode/R_vscode_doc.html",
    "href": "R/R_vscode/R_vscode_doc.html",
    "title": "Exemple_quarto",
    "section": "",
    "text": "Niveau de difficulté:\n\nVSCode est un IDE (environnement de dévellopement integré) qui offre une intégration avec de nombreux outils et langages de programmation. L’extension R pour VS Code vous permet de travailler avec R dans un environnement de développement intégré, ce qui peut vous faire gagner du temps. VS Code vous permet de personnaliser l’éditeur de code et les paramètres de l’IDE selon vos besoins.\nInstallation de VScode\nL’installation de vscode se fait sur le site suivant.Selectionner le bon système d’exploitation et télécharger VSCode.\nhttps://code.visualstudio.com/Download\nInstallation de R\nMaintenant que vous êtes sur VSCode, il faut cliquer sur l’icône situé sur le côté :\n\nDans la barre de recherche il faut inscrire R, puis cliquer sur télécharger. Télécharger également Rtools de la même manière que R. Ensuite ouvrez un fichier en cliquant sur file, puis new file et selectionnez le language dans lequel vous souhaitez coder (ici R).\nComment executer le programme?\nIl suffit de cliquer sur le bouton “run” suivant:\n\nComment executer une cellule ?\nIl suffit de se mettre sur la ligne de code à executer et de faire “crtl+entrée” Si cela ne marche pas il peut avoir une erreur de connection entre l’extension Rtools et R. (erreur commune : [Error - 2:58:07 PM] R Tools client: couldn’t create connection to server.) Pour la résoudre: “Crtl+Shift+P”. Cliquez sur préférence : Open Keyboard shortcut et supprimez r.execute in terminal.\nLien de l’explication de résolution d’erreur:\nhttps://stackoverflow.com/questions/75261815/r-tools-client-couldnt-create-connection-to-server-launching-server-using-com"
  }
]